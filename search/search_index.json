{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KOMPUTASI NUMERIK Data Mahasiswa Nama: Muhammad Ali Yusuf NIM: 180411100135 Program studi: Teknik Informatika Kelas: Komputasi Numerik 4B Dosen Pengampu: Mulaab, S.si, M.Kom","title":"Home"},{"location":"#komputasi-numerik","text":"Data Mahasiswa Nama: Muhammad Ali Yusuf NIM: 180411100135 Program studi: Teknik Informatika Kelas: Komputasi Numerik 4B Dosen Pengampu: Mulaab, S.si, M.Kom","title":"KOMPUTASI NUMERIK"},{"location":"assignments/","text":"Error in Numerical Computations Metode perhitungan Komputasi Numerik digunakan apabila suatu perhitungan tidak bisa diselesaikan melalui penyelesaian secara matematik, maka berlaku penggunaan penyelesaian secara analitik. Berikut beberapa jenis error dan algoritma penyelesaian dalam komputasi numerik: Round-off Error Penyelesaian dengan metode numerik sering kali menggunakan bilangan riil. Error terjadi apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Truncation Error Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi. Definisi Maclaurin Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang terus menerus dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi ke dalam Deret Taylor. Dengan algoritma di atas kita dapat menyerderhanakannya sebagai berikut: Contoh soal: f(x)= e2x ; dengan nilai x=0 f(x)\u22481+2x+f(2x2)3!+f(2x3)3!+\u2026+\u2026 Masukkan nilai x=0 f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026 Maka x = 0 maka hasil akan tetap 1 mekipun banyak suku dan iterasi Task Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001. Penyelesaian Fungsi awal: f(x)=e3x Fungsi awal diturunkan sampai dengan iterasi yang dibutuhkan: f(a)=e3xf(a)=e3xf1(a)=3e3xf1(a)=3e3x f2(a)=9e3xf2(a)=9e3x f3(a)=27e3xf3(a)=27e3x ... Hasil dari fungsi turunan dimasukkan ke dalam rumus deret Maclaurin, sehingga didapatkan penyelesaian: f(x)=1+31!x+92!x2+273!x3+814!x4+...+3nn!xn Kemudian masukkan nilai x=4 f(x)=1+31!4+92!42+273!43+814!44+...+3nn!4n perhitungan diatas akan terus diiterasi hingga nilai selisih mendekati nilai error suku terakhir dan satu suku terakhir sebelumnya yaitu kurang dari 0,001 Listing Program Script code import math x=int(input(\"Masukkan nilai x=\")) nilai = 1 sukuSebelum = 0 sukuSetelah = 1 while nilai>0.001: f_x = 0 f_y = 0 for i in range(sukuSebelum): f_x += (3**i)*x**i/math.factorial(i) for j in range(sukuSetelah): f_y += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",sukuSebelum,\"=\",f_x) print(\"Suku ke-\",sukuSetelah,\"=\",f_y) nilai = f_y-f_x sukuSebelum+=1 awalSetelah+=1 print(\"Hasil selisih =\",nilai) Output: Masukkan nilai x=4 Suku ke- 0 = 0 Suku ke- 1 = 1.0 Hasil selisih = 1.0 Suku ke- 1 = 1.0 Suku ke- 2 = 13.0 Hasil selisih = 12.0 Suku ke- 2 = 13.0 Suku ke- 3 = 85.0 Hasil selisih = 72.0 Suku ke- 3 = 85.0 Suku ke- 4 = 373.0 Hasil selisih = 288.0 Suku ke- 4 = 373.0 Suku ke- 5 = 1237.0 Hasil selisih = 864.0 Suku ke- 5 = 1237.0 Suku ke- 6 = 3310.6 Hasil selisih = 2073.6 Suku ke- 6 = 3310.6 Suku ke- 7 = 7457.799999999999 Hasil selisih = 4147.199999999999 Suku ke- 7 = 7457.799999999999 Suku ke- 8 = 14567.285714285714 Hasil selisih = 7109.4857142857145 Suku ke- 8 = 14567.285714285714 Suku ke- 9 = 25231.514285714286 Hasil selisih = 10664.228571428572 Suku ke- 9 = 25231.514285714286 Suku ke- 10 = 39450.485714285714 Hasil selisih = 14218.971428571429 Suku ke- 10 = 39450.485714285714 Suku ke- 11 = 56513.25142857143 Hasil selisih = 17062.765714285713 Suku ke- 11 = 56513.25142857143 Suku ke- 12 = 75127.17766233766 Hasil selisih = 18613.926233766237 Suku ke- 12 = 75127.17766233766 Suku ke- 13 = 93741.1038961039 Hasil selisih = 18613.926233766237 Suku ke- 13 = 93741.1038961039 Suku ke- 14 = 110923.18965034965 Hasil selisih = 17182.085754245752 Suku ke- 14 = 110923.18965034965 Suku ke- 15 = 125650.69172541745 Hasil selisih = 14727.502075067794 Suku ke- 15 = 125650.69172541745 Suku ke- 16 = 137432.69338547168 Hasil selisih = 11782.00166005423 Suku ke- 16 = 137432.69338547168 Suku ke- 17 = 146269.19463051236 Hasil selisih = 8836.50124504068 Suku ke- 17 = 146269.19463051236 Suku ke- 18 = 152506.7249211293 Hasil selisih = 6237.530290616938 Suku ke- 18 = 152506.7249211293 Suku ke- 19 = 156665.07844820726 Hasil selisih = 4158.3535270779685 Suku ke- 19 = 156665.07844820726 Suku ke- 20 = 159291.4069916249 Hasil selisih = 2626.3285434176505 Suku ke- 20 = 159291.4069916249 Suku ke- 21 = 160867.20411767552 Hasil selisih = 1575.797126050602 Suku ke- 21 = 160867.20411767552 Suku ke- 22 = 161767.65961827585 Hasil selisih = 900.4555006003357 Suku ke- 22 = 161767.65961827585 Suku ke- 23 = 162258.81716405787 Hasil selisih = 491.1575457820145 Suku ke- 23 = 162258.81716405787 Suku ke- 24 = 162515.07327490064 Hasil selisih = 256.25611084277625 Suku ke- 24 = 162515.07327490064 Suku ke- 25 = 162643.20133032204 Hasil selisih = 128.12805542140268 Suku ke- 25 = 162643.20133032204 Suku ke- 26 = 162704.7027969243 Hasil selisih = 61.501466602261644 Suku ke- 26 = 162704.7027969243 Suku ke- 27 = 162733.08808920227 Hasil selisih = 28.385292277962435 Suku ke- 27 = 162733.08808920227 Suku ke- 28 = 162745.70377465914 Hasil selisih = 12.61568545686896 Suku ke- 28 = 162745.70377465914 Suku ke- 29 = 162751.1104969978 Hasil selisih = 5.406722338666441 Suku ke- 29 = 162751.1104969978 Suku ke- 30 = 162753.3477614138 Hasil selisih = 2.237264416005928 Suku ke- 30 = 162753.3477614138 Suku ke- 31 = 162754.2426671802 Hasil selisih = 0.8949057663849089 Suku ke- 31 = 162754.2426671802 Suku ke- 32 = 162754.58908231556 Hasil selisih = 0.34641513536917046 Suku ke- 32 = 162754.58908231556 Suku ke- 33 = 162754.71898799133 Hasil selisih = 0.12990567577071488 Suku ke- 33 = 162754.71898799133 Suku ke- 34 = 162754.7662264189 Hasil selisih = 0.04723842756357044 Suku ke- 34 = 162754.7662264189 Suku ke- 35 = 162754.7828988051 Hasil selisih = 0.016672386205755174 Suku ke- 35 = 162754.7828988051 Suku ke- 36 = 162754.7886150518 Hasil selisih = 0.005716246698284522 Suku ke- 36 = 162754.7886150518 Suku ke- 37 = 162754.79052046736 Hasil selisih = 0.0019054155563935637 Suku ke- 37 = 162754.79052046736 Suku ke- 38 = 162754.79113843996 Hasil selisih = 0.0006179726042319089","title":"Error in Numerical Computations"},{"location":"assignments/#error-in-numerical-computations","text":"Metode perhitungan Komputasi Numerik digunakan apabila suatu perhitungan tidak bisa diselesaikan melalui penyelesaian secara matematik, maka berlaku penggunaan penyelesaian secara analitik. Berikut beberapa jenis error dan algoritma penyelesaian dalam komputasi numerik:","title":"Error in Numerical Computations"},{"location":"assignments/#round-off-error","text":"Penyelesaian dengan metode numerik sering kali menggunakan bilangan riil. Error terjadi apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer.","title":"Round-off Error"},{"location":"assignments/#truncation-error","text":"Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.","title":"Truncation Error"},{"location":"assignments/#definisi-maclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang terus menerus dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi ke dalam Deret Taylor. Dengan algoritma di atas kita dapat menyerderhanakannya sebagai berikut: Contoh soal: f(x)= e2x ; dengan nilai x=0 f(x)\u22481+2x+f(2x2)3!+f(2x3)3!+\u2026+\u2026 Masukkan nilai x=0 f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026 Maka x = 0 maka hasil akan tetap 1 mekipun banyak suku dan iterasi","title":"Definisi Maclaurin"},{"location":"assignments/#task","text":"Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001.","title":"Task"},{"location":"assignments/#penyelesaian","text":"Fungsi awal: f(x)=e3x Fungsi awal diturunkan sampai dengan iterasi yang dibutuhkan: f(a)=e3xf(a)=e3xf1(a)=3e3xf1(a)=3e3x f2(a)=9e3xf2(a)=9e3x f3(a)=27e3xf3(a)=27e3x ... Hasil dari fungsi turunan dimasukkan ke dalam rumus deret Maclaurin, sehingga didapatkan penyelesaian: f(x)=1+31!x+92!x2+273!x3+814!x4+...+3nn!xn Kemudian masukkan nilai x=4 f(x)=1+31!4+92!42+273!43+814!44+...+3nn!4n perhitungan diatas akan terus diiterasi hingga nilai selisih mendekati nilai error suku terakhir dan satu suku terakhir sebelumnya yaitu kurang dari 0,001","title":"Penyelesaian"},{"location":"assignments/#listing-program","text":"Script code import math x=int(input(\"Masukkan nilai x=\")) nilai = 1 sukuSebelum = 0 sukuSetelah = 1 while nilai>0.001: f_x = 0 f_y = 0 for i in range(sukuSebelum): f_x += (3**i)*x**i/math.factorial(i) for j in range(sukuSetelah): f_y += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",sukuSebelum,\"=\",f_x) print(\"Suku ke-\",sukuSetelah,\"=\",f_y) nilai = f_y-f_x sukuSebelum+=1 awalSetelah+=1 print(\"Hasil selisih =\",nilai) Output: Masukkan nilai x=4 Suku ke- 0 = 0 Suku ke- 1 = 1.0 Hasil selisih = 1.0 Suku ke- 1 = 1.0 Suku ke- 2 = 13.0 Hasil selisih = 12.0 Suku ke- 2 = 13.0 Suku ke- 3 = 85.0 Hasil selisih = 72.0 Suku ke- 3 = 85.0 Suku ke- 4 = 373.0 Hasil selisih = 288.0 Suku ke- 4 = 373.0 Suku ke- 5 = 1237.0 Hasil selisih = 864.0 Suku ke- 5 = 1237.0 Suku ke- 6 = 3310.6 Hasil selisih = 2073.6 Suku ke- 6 = 3310.6 Suku ke- 7 = 7457.799999999999 Hasil selisih = 4147.199999999999 Suku ke- 7 = 7457.799999999999 Suku ke- 8 = 14567.285714285714 Hasil selisih = 7109.4857142857145 Suku ke- 8 = 14567.285714285714 Suku ke- 9 = 25231.514285714286 Hasil selisih = 10664.228571428572 Suku ke- 9 = 25231.514285714286 Suku ke- 10 = 39450.485714285714 Hasil selisih = 14218.971428571429 Suku ke- 10 = 39450.485714285714 Suku ke- 11 = 56513.25142857143 Hasil selisih = 17062.765714285713 Suku ke- 11 = 56513.25142857143 Suku ke- 12 = 75127.17766233766 Hasil selisih = 18613.926233766237 Suku ke- 12 = 75127.17766233766 Suku ke- 13 = 93741.1038961039 Hasil selisih = 18613.926233766237 Suku ke- 13 = 93741.1038961039 Suku ke- 14 = 110923.18965034965 Hasil selisih = 17182.085754245752 Suku ke- 14 = 110923.18965034965 Suku ke- 15 = 125650.69172541745 Hasil selisih = 14727.502075067794 Suku ke- 15 = 125650.69172541745 Suku ke- 16 = 137432.69338547168 Hasil selisih = 11782.00166005423 Suku ke- 16 = 137432.69338547168 Suku ke- 17 = 146269.19463051236 Hasil selisih = 8836.50124504068 Suku ke- 17 = 146269.19463051236 Suku ke- 18 = 152506.7249211293 Hasil selisih = 6237.530290616938 Suku ke- 18 = 152506.7249211293 Suku ke- 19 = 156665.07844820726 Hasil selisih = 4158.3535270779685 Suku ke- 19 = 156665.07844820726 Suku ke- 20 = 159291.4069916249 Hasil selisih = 2626.3285434176505 Suku ke- 20 = 159291.4069916249 Suku ke- 21 = 160867.20411767552 Hasil selisih = 1575.797126050602 Suku ke- 21 = 160867.20411767552 Suku ke- 22 = 161767.65961827585 Hasil selisih = 900.4555006003357 Suku ke- 22 = 161767.65961827585 Suku ke- 23 = 162258.81716405787 Hasil selisih = 491.1575457820145 Suku ke- 23 = 162258.81716405787 Suku ke- 24 = 162515.07327490064 Hasil selisih = 256.25611084277625 Suku ke- 24 = 162515.07327490064 Suku ke- 25 = 162643.20133032204 Hasil selisih = 128.12805542140268 Suku ke- 25 = 162643.20133032204 Suku ke- 26 = 162704.7027969243 Hasil selisih = 61.501466602261644 Suku ke- 26 = 162704.7027969243 Suku ke- 27 = 162733.08808920227 Hasil selisih = 28.385292277962435 Suku ke- 27 = 162733.08808920227 Suku ke- 28 = 162745.70377465914 Hasil selisih = 12.61568545686896 Suku ke- 28 = 162745.70377465914 Suku ke- 29 = 162751.1104969978 Hasil selisih = 5.406722338666441 Suku ke- 29 = 162751.1104969978 Suku ke- 30 = 162753.3477614138 Hasil selisih = 2.237264416005928 Suku ke- 30 = 162753.3477614138 Suku ke- 31 = 162754.2426671802 Hasil selisih = 0.8949057663849089 Suku ke- 31 = 162754.2426671802 Suku ke- 32 = 162754.58908231556 Hasil selisih = 0.34641513536917046 Suku ke- 32 = 162754.58908231556 Suku ke- 33 = 162754.71898799133 Hasil selisih = 0.12990567577071488 Suku ke- 33 = 162754.71898799133 Suku ke- 34 = 162754.7662264189 Hasil selisih = 0.04723842756357044 Suku ke- 34 = 162754.7662264189 Suku ke- 35 = 162754.7828988051 Hasil selisih = 0.016672386205755174 Suku ke- 35 = 162754.7828988051 Suku ke- 36 = 162754.7886150518 Hasil selisih = 0.005716246698284522 Suku ke- 36 = 162754.7886150518 Suku ke- 37 = 162754.79052046736 Hasil selisih = 0.0019054155563935637 Suku ke- 37 = 162754.79052046736 Suku ke- 38 = 162754.79113843996 Hasil selisih = 0.0006179726042319089","title":"Listing Program"},{"location":"assignments2/","text":"Numerical Solution of Algebraic and Transcendental Equations Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Berikut metode-metode numerik yang dapat digunakan untuk mencarian akar persamaan non linear: Metode Bisection Metode Regula Falsi Metode Newton Rapson Motode Secant Metode Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algortima Pada Motode Bisection Definisikan fungsi f(x)f(x) yang akan dicari akarnya Tentukan nilai aa dan bb Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum NN Hitung f(a)f(a) dan f(b)f(b) Jika f(a).f(b)>0f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x=(a+b)/2x=(a+b)/2 Hitung f(x)f(x) Bila f(x).f(a)<0f(x).f(a)<0 maka b=xb=x dan f(b)=f(x)f(b)=f(x), bila tidak maka a=xa=x dan f(a)=f(x)f(a)=f(x) Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 atau iterasi telah mencapai iterasi maks maka proses dihentikan dan didapatkan akar xx, bila tidak, ulangi langkah 6 Listing Program def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835 Metode Regula Falsi Metode ini adalah metode tertua untuk menemukan akar sebenarnya dari persamaan f (x) = 0. Ia juga dikenal sebagai metode akor atau metode interpolasi linier. Seperti metode pembagian dua bagian, posisi yang salah satu metodenya dimulai dengan dua titik a0a0dan b0b0 sedemikian rupa sehingga f (a0a0) dan f(b0b0) memiliki tanda-tanda yang berlawanan, yang menyiratkan oleh teorema nilai menengah bahwa fungsi f memiliki akar dalam interval [a0,b0][a0,b0], dengan asumsi kesinambungan dari fungsi f. Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurnan dari metode bisection. Algortima Pada Motode Regula-Falsi Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Mengecek nilai f(a).f(b)<0f(a).f(b)<0 bila tidak maka proses nilai f(a).f(b)>0f(a).f(b)>0, akan memberhentikan proses perhitungan (program) Mengkalkulasi x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)|x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)| Jika f(a).f(x)<0f(a).f(x)<0 maka b=xb=x, ketika tidak jika f(x)f(b)<0f(x)f(b)<0 maka a=xa=x Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 , \u03f5\u03f5 menjadi akurasi yang ditentukan. Lalu lanjutkan ke Langkah 9 yang lain Langkah 4 Cetak nilai xx yang dibutuhkan akar Listing Program error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259 Metode Newton Raphson Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection. Algortima Pada Motode Newton Raphson Definisikan fungsi f(x),f\u2032(x)f(x),f\u2032(x) yang akan dicari akarnya Tentukan tebakan awal akar (katakanlah x0x0) dan set n=0n=0 Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung xn+1=xn\u2212[f(xn)/f\u2032(x)n]xn+1=xn\u2212[f(xn)/f\u2032(x)n] Jika |xn+1\u2212xn|<e|xn+1\u2212xn|<e , di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 7, bila lanjut ke langkah 6 Set n=n+1n=n+1 dan pergi ke langkah 4 Cetak nilai xnxn yang merupakan nilai akar yang diperlukan Listing Program def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035 Metode Secant Metode secant merupakan perbaikan dari metode regula-falsi dan newton raphson dimana kemiringan dua titik dinyatakan sacara diskrit, dengan mengambil bentuk garis lurus yang melalui satu titik. Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi f(x) harus memiliki turunan f'(x). Sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik (x0,f(x0))(x0,f(x0)) dan (x1,f(x1))(x1,f(x1)). Perhatikan gambar dibawah ini. Algortima Pada dengan Motode Secant Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Menghitung x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a)x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a) Jika |a\u2212b|<\u03f5,\u03f5|a\u2212b|<\u03f5,\u03f5 di mana \u03f5\u03f5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 8, bila tidak lanjut ke langkah 7 Set a=ba=b , b=xb=x dan pergi ke langkah ke 4 Cetak nilai xx yang merupakan nilai akar yang dicari. Listing Program def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Numerical Solution of Algebraic and Transcendental Equations"},{"location":"assignments2/#numerical-solution-of-algebraic-and-transcendental-equations","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Berikut metode-metode numerik yang dapat digunakan untuk mencarian akar persamaan non linear: Metode Bisection Metode Regula Falsi Metode Newton Rapson Motode Secant","title":"Numerical Solution of Algebraic and Transcendental Equations"},{"location":"assignments2/#metode-bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan.","title":"Metode Bisection"},{"location":"assignments2/#algortima-pada-motode-bisection","text":"Definisikan fungsi f(x)f(x) yang akan dicari akarnya Tentukan nilai aa dan bb Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum NN Hitung f(a)f(a) dan f(b)f(b) Jika f(a).f(b)>0f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x=(a+b)/2x=(a+b)/2 Hitung f(x)f(x) Bila f(x).f(a)<0f(x).f(a)<0 maka b=xb=x dan f(b)=f(x)f(b)=f(x), bila tidak maka a=xa=x dan f(a)=f(x)f(a)=f(x) Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 atau iterasi telah mencapai iterasi maks maka proses dihentikan dan didapatkan akar xx, bila tidak, ulangi langkah 6","title":"Algortima Pada Motode Bisection"},{"location":"assignments2/#listing-program","text":"def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835","title":"Listing Program"},{"location":"assignments2/#metode-regula-falsi","text":"Metode ini adalah metode tertua untuk menemukan akar sebenarnya dari persamaan f (x) = 0. Ia juga dikenal sebagai metode akor atau metode interpolasi linier. Seperti metode pembagian dua bagian, posisi yang salah satu metodenya dimulai dengan dua titik a0a0dan b0b0 sedemikian rupa sehingga f (a0a0) dan f(b0b0) memiliki tanda-tanda yang berlawanan, yang menyiratkan oleh teorema nilai menengah bahwa fungsi f memiliki akar dalam interval [a0,b0][a0,b0], dengan asumsi kesinambungan dari fungsi f. Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurnan dari metode bisection.","title":"Metode Regula Falsi"},{"location":"assignments2/#algortima-pada-motode-regula-falsi","text":"Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Mengecek nilai f(a).f(b)<0f(a).f(b)<0 bila tidak maka proses nilai f(a).f(b)>0f(a).f(b)>0, akan memberhentikan proses perhitungan (program) Mengkalkulasi x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)|x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)| Jika f(a).f(x)<0f(a).f(x)<0 maka b=xb=x, ketika tidak jika f(x)f(b)<0f(x)f(b)<0 maka a=xa=x Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 , \u03f5\u03f5 menjadi akurasi yang ditentukan. Lalu lanjutkan ke Langkah 9 yang lain Langkah 4 Cetak nilai xx yang dibutuhkan akar","title":"Algortima Pada Motode Regula-Falsi"},{"location":"assignments2/#listing-program_1","text":"error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259","title":"Listing Program"},{"location":"assignments2/#metode-newton-raphson","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection.","title":"Metode Newton Raphson"},{"location":"assignments2/#algortima-pada-motode-newton-raphson","text":"Definisikan fungsi f(x),f\u2032(x)f(x),f\u2032(x) yang akan dicari akarnya Tentukan tebakan awal akar (katakanlah x0x0) dan set n=0n=0 Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung xn+1=xn\u2212[f(xn)/f\u2032(x)n]xn+1=xn\u2212[f(xn)/f\u2032(x)n] Jika |xn+1\u2212xn|<e|xn+1\u2212xn|<e , di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 7, bila lanjut ke langkah 6 Set n=n+1n=n+1 dan pergi ke langkah 4 Cetak nilai xnxn yang merupakan nilai akar yang diperlukan","title":"Algortima Pada Motode Newton Raphson"},{"location":"assignments2/#listing-program_2","text":"def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035","title":"Listing Program"},{"location":"assignments2/#metode-secant","text":"Metode secant merupakan perbaikan dari metode regula-falsi dan newton raphson dimana kemiringan dua titik dinyatakan sacara diskrit, dengan mengambil bentuk garis lurus yang melalui satu titik. Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi f(x) harus memiliki turunan f'(x). Sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik (x0,f(x0))(x0,f(x0)) dan (x1,f(x1))(x1,f(x1)). Perhatikan gambar dibawah ini.","title":"Metode Secant"},{"location":"assignments2/#algortima-pada-dengan-motode-secant","text":"Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Menghitung x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a)x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a) Jika |a\u2212b|<\u03f5,\u03f5|a\u2212b|<\u03f5,\u03f5 di mana \u03f5\u03f5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 8, bila tidak lanjut ke langkah 7 Set a=ba=b , b=xb=x dan pergi ke langkah ke 4 Cetak nilai xx yang merupakan nilai akar yang dicari.","title":"Algortima Pada dengan Motode Secant"},{"location":"assignments2/#listing-program_3","text":"def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Listing Program"},{"location":"assignments3/","text":"Interpolation Interpolation yang akan dibahas pada page ini adalah tentang penerapan Metode Gauss, Metode Gauss Jordan, Metode Gauss Jacobi, dan Metode Gauss Seidel pada persamaan linear. Eliminasi Gauss Eliminasi Gauss adalah sebuah cara mengoperasikan nilai-nilai yang berada di dalam matriks sehingga dapat menjadi matriks yang lebih sederhana. Caranya yaitu melakukan operasi baris sehingga matriks tersebut menjadi matriks yang eselon-baris. Langkah ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks Eselon-baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Mencari solusi persamaan linear eliminasi Gauss dengan membuat Upper Triangular Matrix terdiri dari dua tahap: Forward Elimination (eliminasi maju) - Tujuan Forward Elimination adalah untuk membentuk matriks koefisien menjadi Upper Triangular Matrix . Backward substitution (substitusi mundur) - Proses penyelesaian sistem persamaan linear yang telah diubah menjadi bentuk eselon baris atau bentuk eselon baris tereduksi. Persamaan terakhir diselesaikan pertama, lalu selanjutnya ke terakhir. Eliminasi Gauss Jordan Metode eliminasi Gauss Jordan merupakan pengembangan metode eliminasi Gauss, hanya saja pada eliminasi Gauss Jordan matriks dirubah menjadi matrik diagonal. Algoritma : masukkan matrik A, dan vektor B beserta ukurannya n buat augmented matrik [A|B] namakan dengan A Untuk baris ke i dimana i=1 s/d n a. perhatikan nilai a(i,i) sama dengan 0 jika benar maka baris ke i dan baris i+k<=n, dimana a(i+k,i) tidak sama dengan nol, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. jika tidak maka dilanjutkan b. Jadikan nilai diagonalnya menjadi satu,dengan cara untuk setiap kolam k di mana k=1 s/d n+1, hitung a(i,k) = a(i,k) / a(i,j). Listing Program Persamaan: | 2 5 3 = 1 | | 3 4 2 = -3 | | 1 3 1 = 2 | import numpy as np #Definisi Matrix m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) print() #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai x',m+1, '=',x[m]) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 2 Masukkan a1,2: 5 Masukkan a1,3: 3 Masukkan Hasil: 1 Masukkan a2,1: 3 Masukkan a2,2: 4 Masukkan a2,3: 2 Masukkan Hasil: -3 Masukkan a3,1: 1 Masukkan a3,2: 3 Masukkan a3,3: 1 Masukkan Hasil: 2 Matrix A : [[ 2. 5. 3. ] [ 0. -3.5 -2.5 ] [ 0. 0. -0.85714286]] Nilai x 3 = -1.0000000000000002 Nilai x 2 = 2.0 Nilai x 1 = -2.9999999999999996 Maka diperoleh x= -3 ; y = 2 ; z = -1 Eliminasi Gauss Jacobi Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakukan perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0, kemudian membentuk suatu serangkaian vector X1, X2, \u2026 yang konvergen ke X. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Listing Program Persamaan | 3 1 -1 = 5 | | 4 7 -3 = 20 | | 2 -2 5 =10 | from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): if x is None: x = zeros(len(A[0])) D = diag(A) R = A - diagflat(D) for i in range(N): x = (b - dot(R,x)) / D return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix = array(a,float) Hasil = array(b,float) x=len(a) guess = np.zeros(x,float) sol = jacobi(Matrix,Hasil,N=25,x=guess) print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print(\"x:\") pprint(sol) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 3 Masukkan a1,2: 1 Masukkan a1,3: -1 Masukkan Hasil: 5 Masukkan a2,1: 4 Masukkan a2,2: 7 Masukkan a2,3: -3 Masukkan Hasil: 20 Masukkan a3,1: 2 Masukkan a3,2: -2 Masukkan a3,3: 5 Masukkan Hasil: 10 Matrix: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) Hasil: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Eliminasi Gauss Seidel Metode iterasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah dan akhirnya relatif konstan. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Gauss ini mempunyai kelebihan dan kekurangan. Kelebihannya yaitu Metode eliminasi gauss-seidel digunakan untuk menyelesaikan SPL yang berukuran kecil karena metode ini lebih efisien. Dengan metode iterasi Gauss-Seidel toleransi pembulatan dapat diperkecil karena iterasi dapat diteruskan sampai seteliti mungkin sesuai dengan batas toleransi yang diinginkan. Kekurangannya atau Kelemahan dari metode ini adalah masalah pivot (titik tengah) yang harus benar\u2013benar diperhatikan, karena penyusunan yang salah akan menyebabkan iterasi menjadi divergen dan tidak diperoleh hasil yang benar. Listing Program Persamaan | 4 -1 1 = 7 | | 4 -8 1 = -21 | | -2 1 5 = 15 | from pprint import pprint import numpy as np def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print() for i in range(0, 100): x = seidel(a, x, b) print(\"Jawaban :\",x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 Matrix: array([[ 4., -1., 1.], [ 4., -8., 1.], [-2., 1., 5.]]) Hasil: array([ 7., -21., 15.]) Jawaban : [2.0, 4.0, 3.0] Iterasi yang digunakan sebanyak 100 iterasi, sehingga dapat menghasilkan: x = 2 ; y = 4 ; z = 3","title":"Interpolation"},{"location":"assignments3/#interpolation","text":"Interpolation yang akan dibahas pada page ini adalah tentang penerapan Metode Gauss, Metode Gauss Jordan, Metode Gauss Jacobi, dan Metode Gauss Seidel pada persamaan linear.","title":"Interpolation"},{"location":"assignments3/#eliminasi-gauss","text":"Eliminasi Gauss adalah sebuah cara mengoperasikan nilai-nilai yang berada di dalam matriks sehingga dapat menjadi matriks yang lebih sederhana. Caranya yaitu melakukan operasi baris sehingga matriks tersebut menjadi matriks yang eselon-baris. Langkah ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks Eselon-baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Mencari solusi persamaan linear eliminasi Gauss dengan membuat Upper Triangular Matrix terdiri dari dua tahap: Forward Elimination (eliminasi maju) - Tujuan Forward Elimination adalah untuk membentuk matriks koefisien menjadi Upper Triangular Matrix . Backward substitution (substitusi mundur) - Proses penyelesaian sistem persamaan linear yang telah diubah menjadi bentuk eselon baris atau bentuk eselon baris tereduksi. Persamaan terakhir diselesaikan pertama, lalu selanjutnya ke terakhir.","title":"Eliminasi Gauss"},{"location":"assignments3/#eliminasi-gauss-jordan","text":"Metode eliminasi Gauss Jordan merupakan pengembangan metode eliminasi Gauss, hanya saja pada eliminasi Gauss Jordan matriks dirubah menjadi matrik diagonal. Algoritma : masukkan matrik A, dan vektor B beserta ukurannya n buat augmented matrik [A|B] namakan dengan A Untuk baris ke i dimana i=1 s/d n a. perhatikan nilai a(i,i) sama dengan 0 jika benar maka baris ke i dan baris i+k<=n, dimana a(i+k,i) tidak sama dengan nol, bila tidak ada berarti perhitungan tidak bisa dilanjutkan dan proses dihentikan dengan tanpa penyelesaian. jika tidak maka dilanjutkan b. Jadikan nilai diagonalnya menjadi satu,dengan cara untuk setiap kolam k di mana k=1 s/d n+1, hitung a(i,k) = a(i,k) / a(i,j).","title":"Eliminasi Gauss Jordan"},{"location":"assignments3/#listing-program","text":"Persamaan: | 2 5 3 = 1 | | 3 4 2 = -3 | | 1 3 1 = 2 | import numpy as np #Definisi Matrix m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) print() #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai x',m+1, '=',x[m]) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 2 Masukkan a1,2: 5 Masukkan a1,3: 3 Masukkan Hasil: 1 Masukkan a2,1: 3 Masukkan a2,2: 4 Masukkan a2,3: 2 Masukkan Hasil: -3 Masukkan a3,1: 1 Masukkan a3,2: 3 Masukkan a3,3: 1 Masukkan Hasil: 2 Matrix A : [[ 2. 5. 3. ] [ 0. -3.5 -2.5 ] [ 0. 0. -0.85714286]] Nilai x 3 = -1.0000000000000002 Nilai x 2 = 2.0 Nilai x 1 = -2.9999999999999996 Maka diperoleh x= -3 ; y = 2 ; z = -1","title":"Listing Program"},{"location":"assignments3/#eliminasi-gauss-jacobi","text":"Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakukan perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0, kemudian membentuk suatu serangkaian vector X1, X2, \u2026 yang konvergen ke X. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar.","title":"Eliminasi Gauss Jacobi"},{"location":"assignments3/#listing-program_1","text":"Persamaan | 3 1 -1 = 5 | | 4 7 -3 = 20 | | 2 -2 5 =10 | from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): if x is None: x = zeros(len(A[0])) D = diag(A) R = A - diagflat(D) for i in range(N): x = (b - dot(R,x)) / D return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix = array(a,float) Hasil = array(b,float) x=len(a) guess = np.zeros(x,float) sol = jacobi(Matrix,Hasil,N=25,x=guess) print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print(\"x:\") pprint(sol) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 3 Masukkan a1,2: 1 Masukkan a1,3: -1 Masukkan Hasil: 5 Masukkan a2,1: 4 Masukkan a2,2: 7 Masukkan a2,3: -3 Masukkan Hasil: 20 Masukkan a3,1: 2 Masukkan a3,2: -2 Masukkan a3,3: 5 Masukkan Hasil: 10 Matrix: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) Hasil: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"assignments3/#eliminasi-gauss-seidel","text":"Metode iterasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah dan akhirnya relatif konstan. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Gauss ini mempunyai kelebihan dan kekurangan. Kelebihannya yaitu Metode eliminasi gauss-seidel digunakan untuk menyelesaikan SPL yang berukuran kecil karena metode ini lebih efisien. Dengan metode iterasi Gauss-Seidel toleransi pembulatan dapat diperkecil karena iterasi dapat diteruskan sampai seteliti mungkin sesuai dengan batas toleransi yang diinginkan. Kekurangannya atau Kelemahan dari metode ini adalah masalah pivot (titik tengah) yang harus benar\u2013benar diperhatikan, karena penyusunan yang salah akan menyebabkan iterasi menjadi divergen dan tidak diperoleh hasil yang benar.","title":"Eliminasi Gauss Seidel"},{"location":"assignments3/#listing-program_2","text":"Persamaan | 4 -1 1 = 7 | | 4 -8 1 = -21 | | -2 1 5 = 15 | from pprint import pprint import numpy as np def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) print() b.append(h) a.append(mat1) Matrix=np.array(a,float) Hasil=np.array(b,float) n = len(a) x = [0, 0, 0] print(\"Matrix:\") pprint(Matrix) print(\"Hasil:\") pprint(Hasil) print() for i in range(0, 100): x = seidel(a, x, b) print(\"Jawaban :\",x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 Matrix: array([[ 4., -1., 1.], [ 4., -8., 1.], [-2., 1., 5.]]) Hasil: array([ 7., -21., 15.]) Jawaban : [2.0, 4.0, 3.0] Iterasi yang digunakan sebanyak 100 iterasi, sehingga dapat menghasilkan: x = 2 ; y = 4 ; z = 3","title":"Listing Program"},{"location":"assignments4/","text":"Romberg Method Metode Romberg Metode Romberg merupakan metode integrasi yang didasarkan pada perluasan ekstrapolasi Richardson yang dihasilkan dari aturan trapesium rekursif. Kelemahan dari metode ini adalah harus menggunakan jumlah interval yang besar guna mencapai akurasi yang diharapkan. Salah satu cara untuk meningkatkan akurasi adalah dengan membagi dua interval secara terus menerus sampai nilai integral yang dihitung dengan 2^k dan 2^k+1 konvergen pada suatu nilai. Metode ini sering digunakan untuk memperbaiki hasil aproksimasi oleh metode selisih terhingga. Metode ini dipakai untuk evalusasi numerik dari integrasl tertentu. Untuk dua interval bagian yang berbeda yang panjangnya h1 dan h2 akan diperoleh aproksimasi nilai-nilai I1 dan I2 . Kemudian diperoleh kekeliruan E1 dan E2 . Algoritma Metode Romberg Mendefinisikan fungsi integral f(x) Menentukan batas-batas integral dengan nilai konstanta Menentukan jumlah iterasi (N) Menentukan nilai interval pada [a,b] atau bisa dengan [x2,x1] lalu menghitung h nya dengan cara : h=x2\u2212x1 Menghitung nilai integrasi pada kolom pertama dengan rumus : R(1,1) = T0 = h2(f(x1,y)+f(x2,y)) Menghitung nilai integrasi pada baris kedua sampai n pada kolom pertama dengan rumus : R(n,1) = T_{k+1} = {T_k \\over 2} + {h \\over 2^{k+1}} \\sum^{2^k} {n=1}f {2r-1};f(i) = f(x_1+ i {h \\over 2^{k+1}}, n>=2) Menghitung nilai integrasi pada kolom kedua sampai n dengan menggunakan rumus integrasi Romberg : R(n,m) = 4m\u22121R(n,m\u22121)\u2212R(n\u22121,m\u22121) / 4m\u22121\u22121 Integrasi Romberg juga dapat diartikan sebagai teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( ekstrapolasi Richardson ( Richardso Richardson\u2019s n\u2019s extrapol extrapolation ation), yaitu metode untuk mengkombinasikan ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( integral dalam batas toleransi kesalahan (error tolerance error tolerance) yang sudah ditentukan terlebih dahulu. ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode t kesalahan metode trapesium \u201ccukup\u201d besar rapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi pangkat tinggidan fungsi transeden. Listing Program import numpy as np def trapezcomp(f, a, b, n): #Inisialisasi h = (b - a) / n x = a #Aturan komposit In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): I = np.zeros((p, p)) for k in range(0, p): #Aturan trapesium komposit untuk 2 ^ k I[k, 0] = trapezcomp(f, a, b, 2**k) #Rumus rekursif romberg for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) #Menampilkan hasil print(I[k, 0:k+1]) return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(\"Solusi yang didapatkan =\",solution) Output [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] Solusi yang didapatkan = 1.0000000081440203 Keterangan: f : fungsi untuk diintegrasikan. a : batas bawah integrasi. b : batas atas. n : jumlah panel untuk dibuat antara a dan b. p : jumlah baris dalam tabel Romberg. Contoh Lain menggunakan persamaan f(x)=1/(1+x) import numpy as np import sys def integrate(fn, a, b, steps=5, debug=False, exact=None): table = np.zeros((steps, steps), dtype=np.float64) pow_4 = 4 ** np.arange(steps, dtype=np.float64) - 1 # trapezoidal rule h = (b - a) table[0, 0] = h * (fn(a) + fn(b)) / 2 for j in range(1, steps): h /= 2 # extended trapezoidal rule table[j, 0] = table[j - 1, 0] / 2 table[j, 0] += h * np.sum(fn(a + i * h) for i in range(1, 2 ** j + 1, 2)) # richardson extrapolation for k in range(1, j + 1): table[j, k] = table[j, k - 1] + (table[j, k - 1] - table[j - 1, k - 1]) / pow_4[k] # debug if debug: print(table, file=sys.stderr) if exact is not None: errors = ['%.2e' % i for i in np.abs(table.diagonal() - exact)] print('abs. error:', errors, file=sys.stderr) return table[-1, -1] # integral[0, 1] of f(x) = 1/1+x print(\"Fungsi f(x) yang digunakan adalah\") print(\"f(x) = 1/1+x\") integrate(lambda x: 1/(1+x), 0, 1, debug=True, exact=2/3) Output Fungsi f(x) yang digunakan adalah f(x) = 1/1+x [[0.75 0. 0. 0. 0. ] [0.70833333333333 0.69444444444444 0. 0. 0. ] [0.69702380952381 0.69325396825397 0.6931746031746 0. 0. ] [0.69412185037185 0.69315453065453 0.69314790148123 0.69314747764483 0. ] [0.69339120220753 0.69314765281942 0.69314719429708 0.69314718307193 0.69314718191674]] abs. error: ['8.33e-02', '2.78e-02', '2.65e-02', '2.65e-02', '2.65e-02'] 0.693147181916745","title":"Romberg Method"},{"location":"assignments4/#romberg-method","text":"","title":"Romberg Method"},{"location":"assignments4/#metode-romberg","text":"Metode Romberg merupakan metode integrasi yang didasarkan pada perluasan ekstrapolasi Richardson yang dihasilkan dari aturan trapesium rekursif. Kelemahan dari metode ini adalah harus menggunakan jumlah interval yang besar guna mencapai akurasi yang diharapkan. Salah satu cara untuk meningkatkan akurasi adalah dengan membagi dua interval secara terus menerus sampai nilai integral yang dihitung dengan 2^k dan 2^k+1 konvergen pada suatu nilai. Metode ini sering digunakan untuk memperbaiki hasil aproksimasi oleh metode selisih terhingga. Metode ini dipakai untuk evalusasi numerik dari integrasl tertentu. Untuk dua interval bagian yang berbeda yang panjangnya h1 dan h2 akan diperoleh aproksimasi nilai-nilai I1 dan I2 . Kemudian diperoleh kekeliruan E1 dan E2 . Algoritma Metode Romberg Mendefinisikan fungsi integral f(x) Menentukan batas-batas integral dengan nilai konstanta Menentukan jumlah iterasi (N) Menentukan nilai interval pada [a,b] atau bisa dengan [x2,x1] lalu menghitung h nya dengan cara : h=x2\u2212x1 Menghitung nilai integrasi pada kolom pertama dengan rumus : R(1,1) = T0 = h2(f(x1,y)+f(x2,y)) Menghitung nilai integrasi pada baris kedua sampai n pada kolom pertama dengan rumus : R(n,1) = T_{k+1} = {T_k \\over 2} + {h \\over 2^{k+1}} \\sum^{2^k} {n=1}f {2r-1};f(i) = f(x_1+ i {h \\over 2^{k+1}}, n>=2) Menghitung nilai integrasi pada kolom kedua sampai n dengan menggunakan rumus integrasi Romberg : R(n,m) = 4m\u22121R(n,m\u22121)\u2212R(n\u22121,m\u22121) / 4m\u22121\u22121 Integrasi Romberg juga dapat diartikan sebagai teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( ekstrapolasi Richardson ( Richardso Richardson\u2019s n\u2019s extrapol extrapolation ation), yaitu metode untuk mengkombinasikan ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( integral dalam batas toleransi kesalahan (error tolerance error tolerance) yang sudah ditentukan terlebih dahulu. ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode t kesalahan metode trapesium \u201ccukup\u201d besar rapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi pangkat tinggidan fungsi transeden.","title":"Metode Romberg"},{"location":"assignments4/#listing-program","text":"import numpy as np def trapezcomp(f, a, b, n): #Inisialisasi h = (b - a) / n x = a #Aturan komposit In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): I = np.zeros((p, p)) for k in range(0, p): #Aturan trapesium komposit untuk 2 ^ k I[k, 0] = trapezcomp(f, a, b, 2**k) #Rumus rekursif romberg for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) #Menampilkan hasil print(I[k, 0:k+1]) return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(\"Solusi yang didapatkan =\",solution) Output [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] Solusi yang didapatkan = 1.0000000081440203 Keterangan: f : fungsi untuk diintegrasikan. a : batas bawah integrasi. b : batas atas. n : jumlah panel untuk dibuat antara a dan b. p : jumlah baris dalam tabel Romberg. Contoh Lain menggunakan persamaan f(x)=1/(1+x) import numpy as np import sys def integrate(fn, a, b, steps=5, debug=False, exact=None): table = np.zeros((steps, steps), dtype=np.float64) pow_4 = 4 ** np.arange(steps, dtype=np.float64) - 1 # trapezoidal rule h = (b - a) table[0, 0] = h * (fn(a) + fn(b)) / 2 for j in range(1, steps): h /= 2 # extended trapezoidal rule table[j, 0] = table[j - 1, 0] / 2 table[j, 0] += h * np.sum(fn(a + i * h) for i in range(1, 2 ** j + 1, 2)) # richardson extrapolation for k in range(1, j + 1): table[j, k] = table[j, k - 1] + (table[j, k - 1] - table[j - 1, k - 1]) / pow_4[k] # debug if debug: print(table, file=sys.stderr) if exact is not None: errors = ['%.2e' % i for i in np.abs(table.diagonal() - exact)] print('abs. error:', errors, file=sys.stderr) return table[-1, -1] # integral[0, 1] of f(x) = 1/1+x print(\"Fungsi f(x) yang digunakan adalah\") print(\"f(x) = 1/1+x\") integrate(lambda x: 1/(1+x), 0, 1, debug=True, exact=2/3) Output Fungsi f(x) yang digunakan adalah f(x) = 1/1+x [[0.75 0. 0. 0. 0. ] [0.70833333333333 0.69444444444444 0. 0. 0. ] [0.69702380952381 0.69325396825397 0.6931746031746 0. 0. ] [0.69412185037185 0.69315453065453 0.69314790148123 0.69314747764483 0. ] [0.69339120220753 0.69314765281942 0.69314719429708 0.69314718307193 0.69314718191674]] abs. error: ['8.33e-02', '2.78e-02', '2.65e-02', '2.65e-02', '2.65e-02'] 0.693147181916745","title":"Listing Program"}]}