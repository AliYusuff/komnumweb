{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KOMPUTASI NUMERIK Data Mahasiswa Nama: Muhammad Ali Yusuf NIM: 180411100135 Program studi: Teknik Informatika Kelas: Komputasi Numerik 4B Dosen Pengampu: Mulaab, S.si, M.Kom","title":"Home"},{"location":"#komputasi-numerik","text":"Data Mahasiswa Nama: Muhammad Ali Yusuf NIM: 180411100135 Program studi: Teknik Informatika Kelas: Komputasi Numerik 4B Dosen Pengampu: Mulaab, S.si, M.Kom","title":"KOMPUTASI NUMERIK"},{"location":"assignments/","text":"Error in Numerical Computations Metode perhitungan Komputasi Numerik digunakan apabila suatu perhitungan tidak bisa diselesaikan melalui penyelesaian secara matematik, maka berlaku penggunaan penyelesaian secara analitik. Berikut beberapa jenis error dan algoritma penyelesaian dalam komputasi numerik: Round-off Error Penyelesaian dengan metode numerik sering kali menggunakan bilangan riil. Error terjadi apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Truncation Error Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi. Definisi Maclaurin Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang terus menerus dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi ke dalam Deret Taylor. Dengan algoritma di atas kita dapat menyerderhanakannya sebagai berikut: Contoh soal: f(x)= e2x ; dengan nilai x=0 f(x)\u22481+2x+f(2x2)3!+f(2x3)3!+\u2026+\u2026 Masukkan nilai x=0 f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026 Maka x = 0 maka hasil akan tetap 1 mekipun banyak suku dan iterasi Task Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001. Penyelesaian Fungsi awal: f(x)=e3x Fungsi awal diturunkan sampai dengan iterasi yang dibutuhkan: f(a)=e3xf(a)=e3xf1(a)=3e3xf1(a)=3e3x f2(a)=9e3xf2(a)=9e3x f3(a)=27e3xf3(a)=27e3x ... Hasil dari fungsi turunan dimasukkan ke dalam rumus deret Maclaurin, sehingga didapatkan penyelesaian: f(x)=1+31!x+92!x2+273!x3+814!x4+...+3nn!xn Kemudian masukkan nilai x=4 f(x)=1+31!4+92!42+273!43+814!44+...+3nn!4n perhitungan diatas akan terus diiterasi hingga nilai selisih mendekati nilai error suku terakhir dan satu suku terakhir sebelumnya yaitu kurang dari 0,001 Listing Program Script code import math x=int(input(\"Masukkan nilai x=\")) nilai = 1 sukuSebelum = 0 sukuSetelah = 1 while nilai>0.001: f_x = 0 f_y = 0 for i in range(sukuSebelum): f_x += (3**i)*x**i/math.factorial(i) for j in range(sukuSetelah): f_y += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",sukuSebelum,\"=\",f_x) print(\"Suku ke-\",sukuSetelah,\"=\",f_y) nilai = f_y-f_x sukuSebelum+=1 awalSetelah+=1 print(\"Hasil selisih =\",nilai) Output: Masukkan nilai x=4 Suku ke- 0 = 0 Suku ke- 1 = 1.0 Hasil selisih = 1.0 Suku ke- 1 = 1.0 Suku ke- 2 = 13.0 Hasil selisih = 12.0 Suku ke- 2 = 13.0 Suku ke- 3 = 85.0 Hasil selisih = 72.0 Suku ke- 3 = 85.0 Suku ke- 4 = 373.0 Hasil selisih = 288.0 Suku ke- 4 = 373.0 Suku ke- 5 = 1237.0 Hasil selisih = 864.0 Suku ke- 5 = 1237.0 Suku ke- 6 = 3310.6 Hasil selisih = 2073.6 Suku ke- 6 = 3310.6 Suku ke- 7 = 7457.799999999999 Hasil selisih = 4147.199999999999 Suku ke- 7 = 7457.799999999999 Suku ke- 8 = 14567.285714285714 Hasil selisih = 7109.4857142857145 Suku ke- 8 = 14567.285714285714 Suku ke- 9 = 25231.514285714286 Hasil selisih = 10664.228571428572 Suku ke- 9 = 25231.514285714286 Suku ke- 10 = 39450.485714285714 Hasil selisih = 14218.971428571429 Suku ke- 10 = 39450.485714285714 Suku ke- 11 = 56513.25142857143 Hasil selisih = 17062.765714285713 Suku ke- 11 = 56513.25142857143 Suku ke- 12 = 75127.17766233766 Hasil selisih = 18613.926233766237 Suku ke- 12 = 75127.17766233766 Suku ke- 13 = 93741.1038961039 Hasil selisih = 18613.926233766237 Suku ke- 13 = 93741.1038961039 Suku ke- 14 = 110923.18965034965 Hasil selisih = 17182.085754245752 Suku ke- 14 = 110923.18965034965 Suku ke- 15 = 125650.69172541745 Hasil selisih = 14727.502075067794 Suku ke- 15 = 125650.69172541745 Suku ke- 16 = 137432.69338547168 Hasil selisih = 11782.00166005423 Suku ke- 16 = 137432.69338547168 Suku ke- 17 = 146269.19463051236 Hasil selisih = 8836.50124504068 Suku ke- 17 = 146269.19463051236 Suku ke- 18 = 152506.7249211293 Hasil selisih = 6237.530290616938 Suku ke- 18 = 152506.7249211293 Suku ke- 19 = 156665.07844820726 Hasil selisih = 4158.3535270779685 Suku ke- 19 = 156665.07844820726 Suku ke- 20 = 159291.4069916249 Hasil selisih = 2626.3285434176505 Suku ke- 20 = 159291.4069916249 Suku ke- 21 = 160867.20411767552 Hasil selisih = 1575.797126050602 Suku ke- 21 = 160867.20411767552 Suku ke- 22 = 161767.65961827585 Hasil selisih = 900.4555006003357 Suku ke- 22 = 161767.65961827585 Suku ke- 23 = 162258.81716405787 Hasil selisih = 491.1575457820145 Suku ke- 23 = 162258.81716405787 Suku ke- 24 = 162515.07327490064 Hasil selisih = 256.25611084277625 Suku ke- 24 = 162515.07327490064 Suku ke- 25 = 162643.20133032204 Hasil selisih = 128.12805542140268 Suku ke- 25 = 162643.20133032204 Suku ke- 26 = 162704.7027969243 Hasil selisih = 61.501466602261644 Suku ke- 26 = 162704.7027969243 Suku ke- 27 = 162733.08808920227 Hasil selisih = 28.385292277962435 Suku ke- 27 = 162733.08808920227 Suku ke- 28 = 162745.70377465914 Hasil selisih = 12.61568545686896 Suku ke- 28 = 162745.70377465914 Suku ke- 29 = 162751.1104969978 Hasil selisih = 5.406722338666441 Suku ke- 29 = 162751.1104969978 Suku ke- 30 = 162753.3477614138 Hasil selisih = 2.237264416005928 Suku ke- 30 = 162753.3477614138 Suku ke- 31 = 162754.2426671802 Hasil selisih = 0.8949057663849089 Suku ke- 31 = 162754.2426671802 Suku ke- 32 = 162754.58908231556 Hasil selisih = 0.34641513536917046 Suku ke- 32 = 162754.58908231556 Suku ke- 33 = 162754.71898799133 Hasil selisih = 0.12990567577071488 Suku ke- 33 = 162754.71898799133 Suku ke- 34 = 162754.7662264189 Hasil selisih = 0.04723842756357044 Suku ke- 34 = 162754.7662264189 Suku ke- 35 = 162754.7828988051 Hasil selisih = 0.016672386205755174 Suku ke- 35 = 162754.7828988051 Suku ke- 36 = 162754.7886150518 Hasil selisih = 0.005716246698284522 Suku ke- 36 = 162754.7886150518 Suku ke- 37 = 162754.79052046736 Hasil selisih = 0.0019054155563935637 Suku ke- 37 = 162754.79052046736 Suku ke- 38 = 162754.79113843996 Hasil selisih = 0.0006179726042319089","title":"Error in Numerical Computations"},{"location":"assignments/#error-in-numerical-computations","text":"Metode perhitungan Komputasi Numerik digunakan apabila suatu perhitungan tidak bisa diselesaikan melalui penyelesaian secara matematik, maka berlaku penggunaan penyelesaian secara analitik. Berikut beberapa jenis error dan algoritma penyelesaian dalam komputasi numerik:","title":"Error in Numerical Computations"},{"location":"assignments/#round-off-error","text":"Penyelesaian dengan metode numerik sering kali menggunakan bilangan riil. Error terjadi apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer.","title":"Round-off Error"},{"location":"assignments/#truncation-error","text":"Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.","title":"Truncation Error"},{"location":"assignments/#definisi-maclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang terus menerus dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi ke dalam Deret Taylor. Dengan algoritma di atas kita dapat menyerderhanakannya sebagai berikut: Contoh soal: f(x)= e2x ; dengan nilai x=0 f(x)\u22481+2x+f(2x2)3!+f(2x3)3!+\u2026+\u2026 Masukkan nilai x=0 f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026f(0)\u22481+2(0)+(2(0)2)3!+(2(0)3)3!+\u2026+\u2026 Maka x = 0 maka hasil akan tetap 1 mekipun banyak suku dan iterasi","title":"Definisi Maclaurin"},{"location":"assignments/#task","text":"Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001.","title":"Task"},{"location":"assignments/#penyelesaian","text":"Fungsi awal: f(x)=e3x Fungsi awal diturunkan sampai dengan iterasi yang dibutuhkan: f(a)=e3xf(a)=e3xf1(a)=3e3xf1(a)=3e3x f2(a)=9e3xf2(a)=9e3x f3(a)=27e3xf3(a)=27e3x ... Hasil dari fungsi turunan dimasukkan ke dalam rumus deret Maclaurin, sehingga didapatkan penyelesaian: f(x)=1+31!x+92!x2+273!x3+814!x4+...+3nn!xn Kemudian masukkan nilai x=4 f(x)=1+31!4+92!42+273!43+814!44+...+3nn!4n perhitungan diatas akan terus diiterasi hingga nilai selisih mendekati nilai error suku terakhir dan satu suku terakhir sebelumnya yaitu kurang dari 0,001","title":"Penyelesaian"},{"location":"assignments/#listing-program","text":"Script code import math x=int(input(\"Masukkan nilai x=\")) nilai = 1 sukuSebelum = 0 sukuSetelah = 1 while nilai>0.001: f_x = 0 f_y = 0 for i in range(sukuSebelum): f_x += (3**i)*x**i/math.factorial(i) for j in range(sukuSetelah): f_y += (3**j)*x**j/math.factorial(j) print(\"Suku ke-\",sukuSebelum,\"=\",f_x) print(\"Suku ke-\",sukuSetelah,\"=\",f_y) nilai = f_y-f_x sukuSebelum+=1 awalSetelah+=1 print(\"Hasil selisih =\",nilai) Output: Masukkan nilai x=4 Suku ke- 0 = 0 Suku ke- 1 = 1.0 Hasil selisih = 1.0 Suku ke- 1 = 1.0 Suku ke- 2 = 13.0 Hasil selisih = 12.0 Suku ke- 2 = 13.0 Suku ke- 3 = 85.0 Hasil selisih = 72.0 Suku ke- 3 = 85.0 Suku ke- 4 = 373.0 Hasil selisih = 288.0 Suku ke- 4 = 373.0 Suku ke- 5 = 1237.0 Hasil selisih = 864.0 Suku ke- 5 = 1237.0 Suku ke- 6 = 3310.6 Hasil selisih = 2073.6 Suku ke- 6 = 3310.6 Suku ke- 7 = 7457.799999999999 Hasil selisih = 4147.199999999999 Suku ke- 7 = 7457.799999999999 Suku ke- 8 = 14567.285714285714 Hasil selisih = 7109.4857142857145 Suku ke- 8 = 14567.285714285714 Suku ke- 9 = 25231.514285714286 Hasil selisih = 10664.228571428572 Suku ke- 9 = 25231.514285714286 Suku ke- 10 = 39450.485714285714 Hasil selisih = 14218.971428571429 Suku ke- 10 = 39450.485714285714 Suku ke- 11 = 56513.25142857143 Hasil selisih = 17062.765714285713 Suku ke- 11 = 56513.25142857143 Suku ke- 12 = 75127.17766233766 Hasil selisih = 18613.926233766237 Suku ke- 12 = 75127.17766233766 Suku ke- 13 = 93741.1038961039 Hasil selisih = 18613.926233766237 Suku ke- 13 = 93741.1038961039 Suku ke- 14 = 110923.18965034965 Hasil selisih = 17182.085754245752 Suku ke- 14 = 110923.18965034965 Suku ke- 15 = 125650.69172541745 Hasil selisih = 14727.502075067794 Suku ke- 15 = 125650.69172541745 Suku ke- 16 = 137432.69338547168 Hasil selisih = 11782.00166005423 Suku ke- 16 = 137432.69338547168 Suku ke- 17 = 146269.19463051236 Hasil selisih = 8836.50124504068 Suku ke- 17 = 146269.19463051236 Suku ke- 18 = 152506.7249211293 Hasil selisih = 6237.530290616938 Suku ke- 18 = 152506.7249211293 Suku ke- 19 = 156665.07844820726 Hasil selisih = 4158.3535270779685 Suku ke- 19 = 156665.07844820726 Suku ke- 20 = 159291.4069916249 Hasil selisih = 2626.3285434176505 Suku ke- 20 = 159291.4069916249 Suku ke- 21 = 160867.20411767552 Hasil selisih = 1575.797126050602 Suku ke- 21 = 160867.20411767552 Suku ke- 22 = 161767.65961827585 Hasil selisih = 900.4555006003357 Suku ke- 22 = 161767.65961827585 Suku ke- 23 = 162258.81716405787 Hasil selisih = 491.1575457820145 Suku ke- 23 = 162258.81716405787 Suku ke- 24 = 162515.07327490064 Hasil selisih = 256.25611084277625 Suku ke- 24 = 162515.07327490064 Suku ke- 25 = 162643.20133032204 Hasil selisih = 128.12805542140268 Suku ke- 25 = 162643.20133032204 Suku ke- 26 = 162704.7027969243 Hasil selisih = 61.501466602261644 Suku ke- 26 = 162704.7027969243 Suku ke- 27 = 162733.08808920227 Hasil selisih = 28.385292277962435 Suku ke- 27 = 162733.08808920227 Suku ke- 28 = 162745.70377465914 Hasil selisih = 12.61568545686896 Suku ke- 28 = 162745.70377465914 Suku ke- 29 = 162751.1104969978 Hasil selisih = 5.406722338666441 Suku ke- 29 = 162751.1104969978 Suku ke- 30 = 162753.3477614138 Hasil selisih = 2.237264416005928 Suku ke- 30 = 162753.3477614138 Suku ke- 31 = 162754.2426671802 Hasil selisih = 0.8949057663849089 Suku ke- 31 = 162754.2426671802 Suku ke- 32 = 162754.58908231556 Hasil selisih = 0.34641513536917046 Suku ke- 32 = 162754.58908231556 Suku ke- 33 = 162754.71898799133 Hasil selisih = 0.12990567577071488 Suku ke- 33 = 162754.71898799133 Suku ke- 34 = 162754.7662264189 Hasil selisih = 0.04723842756357044 Suku ke- 34 = 162754.7662264189 Suku ke- 35 = 162754.7828988051 Hasil selisih = 0.016672386205755174 Suku ke- 35 = 162754.7828988051 Suku ke- 36 = 162754.7886150518 Hasil selisih = 0.005716246698284522 Suku ke- 36 = 162754.7886150518 Suku ke- 37 = 162754.79052046736 Hasil selisih = 0.0019054155563935637 Suku ke- 37 = 162754.79052046736 Suku ke- 38 = 162754.79113843996 Hasil selisih = 0.0006179726042319089","title":"Listing Program"},{"location":"assignments2/","text":"Numerical Solution of Algebraic and Transcendental Equations Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Berikut metode-metode numerik yang dapat digunakan untuk mencarian akar persamaan non linear: Metode Bisection Metode Regula Falsi Metode Newton Rapson Motode Secant Metode Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algortima Pada Motode Bisection Definisikan fungsi f(x)f(x) yang akan dicari akarnya Tentukan nilai aa dan bb Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum NN Hitung f(a)f(a) dan f(b)f(b) Jika f(a).f(b)>0f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x=(a+b)/2x=(a+b)/2 Hitung f(x)f(x) Bila f(x).f(a)<0f(x).f(a)<0 maka b=xb=x dan f(b)=f(x)f(b)=f(x), bila tidak maka a=xa=x dan f(a)=f(x)f(a)=f(x) Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 atau iterasi telah mencapai iterasi maks maka proses dihentikan dan didapatkan akar xx, bila tidak, ulangi langkah 6 Listing Program def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835 Metode Regula Falsi Metode ini adalah metode tertua untuk menemukan akar sebenarnya dari persamaan f (x) = 0. Ia juga dikenal sebagai metode akor atau metode interpolasi linier. Seperti metode pembagian dua bagian, posisi yang salah satu metodenya dimulai dengan dua titik a0a0dan b0b0 sedemikian rupa sehingga f (a0a0) dan f(b0b0) memiliki tanda-tanda yang berlawanan, yang menyiratkan oleh teorema nilai menengah bahwa fungsi f memiliki akar dalam interval [a0,b0][a0,b0], dengan asumsi kesinambungan dari fungsi f. Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurnan dari metode bisection. Algortima Pada Motode Regula-Falsi Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Mengecek nilai f(a).f(b)<0f(a).f(b)<0 bila tidak maka proses nilai f(a).f(b)>0f(a).f(b)>0, akan memberhentikan proses perhitungan (program) Mengkalkulasi x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)|x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)| Jika f(a).f(x)<0f(a).f(x)<0 maka b=xb=x, ketika tidak jika f(x)f(b)<0f(x)f(b)<0 maka a=xa=x Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 , \u03f5\u03f5 menjadi akurasi yang ditentukan. Lalu lanjutkan ke Langkah 9 yang lain Langkah 4 Cetak nilai xx yang dibutuhkan akar Listing Program error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259 Metode Newton Raphson Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection. Algortima Pada Motode Newton Raphson Definisikan fungsi f(x),f\u2032(x)f(x),f\u2032(x) yang akan dicari akarnya Tentukan tebakan awal akar (katakanlah x0x0) dan set n=0n=0 Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung xn+1=xn\u2212[f(xn)/f\u2032(x)n]xn+1=xn\u2212[f(xn)/f\u2032(x)n] Jika |xn+1\u2212xn|<e|xn+1\u2212xn|<e , di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 7, bila lanjut ke langkah 6 Set n=n+1n=n+1 dan pergi ke langkah 4 Cetak nilai xnxn yang merupakan nilai akar yang diperlukan Listing Program def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035 Metode Secant Metode secant merupakan perbaikan dari metode regula-falsi dan newton raphson dimana kemiringan dua titik dinyatakan sacara diskrit, dengan mengambil bentuk garis lurus yang melalui satu titik. Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi f(x) harus memiliki turunan f'(x). Sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik (x0,f(x0))(x0,f(x0)) dan (x1,f(x1))(x1,f(x1)). Perhatikan gambar dibawah ini. Algortima Pada dengan Motode Secant Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Menghitung x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a)x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a) Jika |a\u2212b|<\u03f5,\u03f5|a\u2212b|<\u03f5,\u03f5 di mana \u03f5\u03f5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 8, bila tidak lanjut ke langkah 7 Set a=ba=b , b=xb=x dan pergi ke langkah ke 4 Cetak nilai xx yang merupakan nilai akar yang dicari. Listing Program def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Numerical Solution of Algebraic and Transcendental Equations"},{"location":"assignments2/#numerical-solution-of-algebraic-and-transcendental-equations","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Berikut metode-metode numerik yang dapat digunakan untuk mencarian akar persamaan non linear: Metode Bisection Metode Regula Falsi Metode Newton Rapson Motode Secant","title":"Numerical Solution of Algebraic and Transcendental Equations"},{"location":"assignments2/#metode-bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan.","title":"Metode Bisection"},{"location":"assignments2/#algortima-pada-motode-bisection","text":"Definisikan fungsi f(x)f(x) yang akan dicari akarnya Tentukan nilai aa dan bb Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum NN Hitung f(a)f(a) dan f(b)f(b) Jika f(a).f(b)>0f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan Hitung x=(a+b)/2x=(a+b)/2 Hitung f(x)f(x) Bila f(x).f(a)<0f(x).f(a)<0 maka b=xb=x dan f(b)=f(x)f(b)=f(x), bila tidak maka a=xa=x dan f(a)=f(x)f(a)=f(x) Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 atau iterasi telah mencapai iterasi maks maka proses dihentikan dan didapatkan akar xx, bila tidak, ulangi langkah 6","title":"Algortima Pada Motode Bisection"},{"location":"assignments2/#listing-program","text":"def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) Output 1.9999999985098835","title":"Listing Program"},{"location":"assignments2/#metode-regula-falsi","text":"Metode ini adalah metode tertua untuk menemukan akar sebenarnya dari persamaan f (x) = 0. Ia juga dikenal sebagai metode akor atau metode interpolasi linier. Seperti metode pembagian dua bagian, posisi yang salah satu metodenya dimulai dengan dua titik a0a0dan b0b0 sedemikian rupa sehingga f (a0a0) dan f(b0b0) memiliki tanda-tanda yang berlawanan, yang menyiratkan oleh teorema nilai menengah bahwa fungsi f memiliki akar dalam interval [a0,b0][a0,b0], dengan asumsi kesinambungan dari fungsi f. Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurnan dari metode bisection.","title":"Metode Regula Falsi"},{"location":"assignments2/#algortima-pada-motode-regula-falsi","text":"Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Mengecek nilai f(a).f(b)<0f(a).f(b)<0 bila tidak maka proses nilai f(a).f(b)>0f(a).f(b)>0, akan memberhentikan proses perhitungan (program) Mengkalkulasi x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)|x=(a|f(b)|+b|f(a)|)|f(a)|+|f(b)| Jika f(a).f(x)<0f(a).f(x)<0 maka b=xb=x, ketika tidak jika f(x)f(b)<0f(x)f(b)<0 maka a=xa=x Jika |b\u2212a|<\u03f5|b\u2212a|<\u03f5 , \u03f5\u03f5 menjadi akurasi yang ditentukan. Lalu lanjutkan ke Langkah 9 yang lain Langkah 4 Cetak nilai xx yang dibutuhkan akar","title":"Algortima Pada Motode Regula-Falsi"},{"location":"assignments2/#listing-program_1","text":"error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('Tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) Output x = 2.000000000174259","title":"Listing Program"},{"location":"assignments2/#metode-newton-raphson","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection.","title":"Metode Newton Raphson"},{"location":"assignments2/#algortima-pada-motode-newton-raphson","text":"Definisikan fungsi f(x),f\u2032(x)f(x),f\u2032(x) yang akan dicari akarnya Tentukan tebakan awal akar (katakanlah x0x0) dan set n=0n=0 Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung xn+1=xn\u2212[f(xn)/f\u2032(x)n]xn+1=xn\u2212[f(xn)/f\u2032(x)n] Jika |xn+1\u2212xn|<e|xn+1\u2212xn|<e , di mana \u03b5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 7, bila lanjut ke langkah 6 Set n=n+1n=n+1 dan pergi ke langkah 4 Cetak nilai xnxn yang merupakan nilai akar yang diperlukan","title":"Algortima Pada Motode Newton Raphson"},{"location":"assignments2/#listing-program_2","text":"def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) Output Found solution after 4 iterations. 1.9999847409781035","title":"Listing Program"},{"location":"assignments2/#metode-secant","text":"Metode secant merupakan perbaikan dari metode regula-falsi dan newton raphson dimana kemiringan dua titik dinyatakan sacara diskrit, dengan mengambil bentuk garis lurus yang melalui satu titik. Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen Modifikasi metode Newton Raphson dinamakan metode Secant. Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi f(x) harus memiliki turunan f'(x). Sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik (x0,f(x0))(x0,f(x0)) dan (x1,f(x1))(x1,f(x1)). Perhatikan gambar dibawah ini.","title":"Metode Secant"},{"location":"assignments2/#algortima-pada-dengan-motode-secant","text":"Definisikan fungsi f(x)f(x) yang akan dicari akarnya Masukkan interval [a,b][a,b] dimana akar berada, atau bisa dengan menententukan nilai a dan b Tentukan toleransi \u03f5\u03f5 dan iterasi maksimum N Hitung f(a)f(a) dan f(b)f(b) Menghitung x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a)x=a\u2212[(b\u2212a)/f(b)\u2212f(a)]f(a) Jika |a\u2212b|<\u03f5,\u03f5|a\u2212b|<\u03f5,\u03f5 di mana \u03f5\u03f5 adalah akurasi yang ditentukan, lalu lanjutkan ke Langkah 8, bila tidak lanjut ke langkah 7 Set a=ba=b , b=xb=x dan pergi ke langkah ke 4 Cetak nilai xx yang merupakan nilai akar yang dicari.","title":"Algortima Pada dengan Motode Secant"},{"location":"assignments2/#listing-program_3","text":"def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) Output 2.0000003178913373","title":"Listing Program"}]}